from django.db import models
from django.contrib.auth.models import User

SCHEMA_VERSION = 20

# This is a Django models definition for the kegbot database

class UserLabel(models.Model):
   """ Attributes that may be applied to users.

   TODO(mikey): possibly deprecated.
   """
   class Meta:
      db_table = "userlabels"

   class Admin:
      pass

   labelname = models.CharField(maxlength=128)


class UserProfile(models.Model):
   """ Extra per-User information.

   Since we're using the User table generated by django.contrib.auth, we need
   to extended it in an additional table (rather than by adding columns to
   User.)
   """
   class Meta:
      db_table = "user_profiles"
   class Admin:
      pass

   user = models.OneToOneField(User)
   gender = models.CharField(maxlength=8)
   weight = models.FloatField(max_digits=6, decimal_places=2)
   labels = models.ManyToManyField(UserLabel)
  # grants, tokens, labels

   def HasLabel(self, lbl):
      return lbl in self.labels.select() # XXX FIXME


class Brewer(models.Model):
   """ Record holder for Brewer information """
   class Meta:
      db_table = "brewers"

   class Admin:
      pass

   name = models.CharField(maxlength=128)
   origin_country = models.CharField(maxlength=128, default='')
   origin_state = models.CharField(maxlength=128, default='')
   origin_city = models.CharField(maxlength=128, default='')
   distribution = models.CharField(maxlength=128,
         choices = ( ('retail', 'retail'),
                     ('homebrew', 'homebrew'),
                     ('unknown', 'unknown'),
         ),
         default = 'unknown',
   )
   url = models.URLField(verify_exists=False, default='')
   comment = models.TextField(default='')

   def __str__(self):
      return "%s (%s, %s, %s)" % (self.name, self.origin_city,
            self.origin_state, self.origin_country)


class BeerStyle(models.Model):
   """ Record holder for different styles of beer """
   class Meta:
      db_table = "beerstyles"

   class Admin:
      pass

   name = models.CharField(maxlength=128)

   def __str__(self):
      return self.name


class BeerType(models.Model):
   """ Record to link a beverage to its brewer and composition.

   Each installed Keg must be assigned a BeerType so that various intake
   estimates (BAC, calories, and so on) can be made.
   """
   class Meta:
      db_table = "beertypes"

   class Admin:
      list_display=('name', 'brewer', 'style')

   name = models.CharField(maxlength=128)
   brewer = models.ForeignKey(Brewer)
   style = models.ForeignKey(BeerStyle)
   calories_oz = models.FloatField(max_digits=6,decimal_places=2, default=0)
   carbs_oz = models.FloatField(max_digits=6,decimal_places=2, default=0)
   abv = models.FloatField(max_digits=6, decimal_places=6, default=0)

   def __str__(self):
      return "%s by %s" % (self.name, self.brewer)


class KegSize(models.Model):
   """ A convenient table of common Keg sizes """
   name = models.CharField(maxlength=128)
   volume = models.IntegerField()


class Keg(models.Model):
   """ Record for each installed Keg. """
   class Meta:
      db_table = "kegs"

   class Admin:
      list_display = ('id', 'type')

   def volserved(self):
      drinks = Drink.objects.filter(keg__exact=self,
            status__exact='valid')
      tot = 0.0
      for d in drinks:
         tot += d.volume
      return tot

   def pctremain(self):
      return (self.full_volume - self.volserved())/self.full_volume * 100.0

   type = models.ForeignKey(BeerType)
   size = models.ForeignKey(KegSize)
   startdate = models.DateTimeField('start date')
   enddate = models.DateTimeField('end date')
   channel = models.IntegerField()
   status = models.CharField(maxlength=128, choices=(
      ('online', 'online'),
      ('offline', 'offline'),
      ('coming soon', 'coming soon')))
   description = models.CharField(maxlength=128)
   origcost = models.FloatField(max_digits=6,decimal_places=2)

   def __str__(self):
      return "Keg #%s - %s" % (self.id, self.type)


class Drink(models.Model):
   """ Table of drinks records """
   class Meta:
      db_table = "drinks"
      get_latest_by = "starttime"

   class Admin:
      pass

   def ounces(self):
      return self.volume/units.US_OUNCE

   def calories(self):
      cal = self.keg.type.calories_oz*self.ounces()
      return cal

   def bac(self):
      bacs = BAC.objects.filter(drink__exact=self)
      if bacs.count() == 1:
         return bacs[0].bac
      return 0

   # Ticks and volume may seem redundant; volume is stored in "volunits" which
   # happen to be the exact volume of one tick. The idea here is to always
   # store the meter reading, in case the value of a volunit changes, and to
   # allow calibration. Kegbot code never touches the ticks field after saving
   # it; all operations concerning volume use the volume field.
   ticks = models.PositiveIntegerField()
   volume = models.PositiveIntegerField()

   # Similarly, recording both the start and end times of a drink may seem odd.
   # The idea was to someday add metrics to the web page showing pour speeds.
   # This was never terribly exciting so it didn't happen, but space is cheap
   # so I'm inclined to keep the data rather than chuck it.
   #
   # For sorting and other operations requiring a single date, the endtime is
   # used.  TODO(mikey): make sure this is actually the case
   starttime = models.DateTimeField('drink start')
   endtime = models.DateTimeField('drink end')
   user = models.ForeignKey(User)
   keg = models.ForeignKey(Keg)
   status = models.CharField(maxlength=128, choices = (
      ('valid', 'valid'),
      ('invalid', 'invalid'),
      ), default = 'valid')

   def __str__(self):
      return "Drink %s by %s" % (self.id, self.user)


class Policy(models.Model):
   """ Cost functions which may be applied on a per-user basis. """
   class Meta:
      db_table = "policies"

   class Admin:
      pass

   type = models.CharField(maxlength=32, choices=(
      ('fixed-cost', 'fixed-cost'),
      ('free', 'free'),
      ), default = 'fixed-cost')
   unitcost = models.FloatField(max_digits=6, decimal_places=4)
   unitvolume = models.PositiveIntegerField()
   description = models.TextField()

   def __str__(self):
      return self.description


class Grant(models.Model):
   """ An assignment of a Policy to a User

   The policy may specify an expiration method
   """
   class Meta:
      db_table = "grants"

   class Admin:
      pass

   user = models.ForeignKey(User)
   expiration = models.CharField(maxlength=128, choices = (
      ('none', 'none'),
      ('time', 'time'),
      ('volume', 'volume'),
      ('drinks', 'drinks'),
      ), default = "none")
   status  = models.CharField(maxlength=128, choices = (
      ('active', 'active'),
      ('expired', 'expired'),
      ('deleted', 'deleted'),
      ), default = 'active')
   policy = models.ForeignKey(Policy)
   exp_volume = models.PositiveIntegerField(default=0)
   exp_time = models.DateTimeField()
   exp_drinks = models.PositiveIntegerField(default=0)
   total_volume = models.PositiveIntegerField(default=0)
   total_drinks = models.PositiveIntegerField()

   def __str__(self):
      return "%s for %s" % (self.policy, self.user)

   def AvailableVolume(self):
      """
      return how much volume is available with this grant, at this instant.
      """
      if self.IsExpired():
         return 0
      if self.expiration == 'volume':
         return max(0, self.exp_volume - self.total_volume)
      else:
         return sys.maxint

   def IsExpired(self, extravolume = 0):
      if self.status != 'active':
         return True
      if self.expiration == "none":
         return False
      elif self.expiration == "time":
         return self.exp_time < datetime.datetime.now()
      elif self.expiration == "volume":
         return (extravolume + self.total_volume) >= self.exp_volume
      else:
         return True

   def IncVolume(self, volume):
      self.total_volume += volume
      if self.expiration == 'volume':
         if self.total_volume >= self.exp_volume:
            self.status = 'expired'
      self.save()

   def ExpiresBefore(self,other):
      """
      determine if this grant will expire sooner than the given one.

      intuitively, this should return 'true' if this grant should be used
      BEFORE the other one (ie, it expires sooner)
      """
      if self.expiration == 'time':
         if other.expiration == 'time':
            return self.exp_time < other.exp_time
         elif other.expiration == 'none':
            return True
      elif self.expiration == 'none':
         return False

      # fall-thru, XXX
      return False

   def MaxVolume(cls, user):
      """ return maximum volume pourable, in range [0, sys.maxint = infty) """
      grants = Grant.objects.filter(user=user)
      tot = 0
      for g in grants:
         vol = g.AvailableVolume()
         if vol == sys.maxint:   # unlimited
            return vol
         else:
            tot += vol
      return tot
   MaxVolume = classmethod(MaxVolume)


class Token(models.Model):
   """ An arbitrary secret key, used by the authentication system.

   This table may need to change as more authentication modules are added.
   TODO(mikey): fix this
   """
   class Meta:
      db_table = "tokens"

   class Admin:
      pass

   user = models.ForeignKey(User)
   keyinfo = models.TextField()
   created = models.DateTimeField()

   def __str__(self):
      return "Token %s for %s" % (self.id, self.user)


class BAC(models.Model):
   """ Calculated table of instantaneous blood alcohol estimations.

   A BAC value may be added by Kegbot after each pour of a registered drinker.
   A relationship to the drink causing the calculation is stored, to ease
   lookup by Drink.

   TODO(mikey): consider making the Drink optional so that intermediate values
   can be added. Seems of dubious utility.
   TODO(mikey): if Drink is mandatory, should eliminated rectime.
   """
   class Meta:
      db_table = "bacs"

   class Admin:
      pass

   user = models.ForeignKey(User)
   drink = models.ForeignKey(Drink)
   rectime = models.DateTimeField()
   bac = models.FloatField(max_digits=6, decimal_places=4)

   def __str__(self):
      return "%s BAC at %s" % (self.user, self.drink)

   def ProcessDrink(cls, d):
      """ Store a BAC value given a recent drink """
      prev_bac = 0.0
      #if not d.user.HasLabel('guest'):
      if True: # XXX FIXME
         # consider previously recorded bac for non-guest users
         matches = BAC.objects.filter(user=d.user).order_by('-rectime')
         if matches.count():
            last_bac = matches[0]
            prev_bac = util.decomposeBAC(last_bac.bac, (d.endtime - last_bac.rectime).seconds)

      now = util.instantBAC(d.user.get_profile().gender,
            d.user.get_profile().weight, d.keg.type.abv, units.to_ounces(d.volume))
      # TODO(mikey): fix this factor
      #now = util.decomposeBAC(now, units.to_ounces(d.volume)/12.0*(30*60))

      b = BAC(user=d.user, drink=d.id, rectime=d.endtime, bac=now+prev_bac)
      b.save()
   ProcessDrink = classmethod(ProcessDrink)


class GrantCharge(models.Model):
   """ A volume deduction against a particular Grant. """
   class Meta:
      db_table = "grantcharges"

   class Admin:
      pass

   grant = models.ForeignKey(Grant)
   drink = models.ForeignKey(Drink)
   user = models.ForeignKey(User)
   volume = models.PositiveIntegerField()


class Binge(models.Model):
   """ A calculated grouping of drinks occuring within a time window """
   class Meta:
      db_table = "binges"

   class Admin:
      pass

   def __str__(self):
      return "binge %s by %s (%s to %s)" % (self.id, self.user, self.starttime, self.endtime)

   user = models.ForeignKey(User)
   startdrink = models.ForeignKey(Drink, related_name='start')
   enddrink = models.ForeignKey(Drink, related_name='end')
   volume = models.PositiveIntegerField()
   starttime = models.DateTimeField()
   endtime = models.DateTimeField()

   def Assign(cls, d):
      """ Create or update a binge given a recent drink """
      #if d.user.HasLabel('guest'):
      if False: # XXX FIXME
         # no binge calculation for guest users
         return -1

      min_end = d.endtime - datetime.timedelta(minutes=90) # FIXME constant
      binges = Binge.objects.filter(user=d.user, endtime__gte=min_end).order_by("-id")[:1]

      # now find or create the current binge, and update it
      if binges.count() == 0:
         last_binge = Binge(user=d.user, startdrink=d,
               enddrink=d, volume=d.volume, starttime=d.endtime,
               endtime=d.endtime)
         last_binge.save()
      else:
         last_binge = binges[0]
         last_binge.volume += d.volume
         last_binge.enddrink = d
         last_binge.endtime = d.endtime
         last_binge.save()
      return last_binge.id
   Assign = classmethod(Assign)


class UserPic(models.Model):
   """ Picture storage within database. """
   class Meta:
      db_table = "userpics"

   class Admin:
      pass

   user = models.ForeignKey(User)
   filetype = models.CharField(maxlength=12)
   modified = models.DateTimeField()
   #data = models.ImageField(upload_to='/tmp') # XXX
   data = models.TextField()


class Thermolog(models.Model):
   """ A log from an ITemperatureSensor device of periodic measurements. """
   class Meta:
      db_table = "thermolog"

   class Admin:
      pass

   name = models.CharField(maxlength=128)
   temp = models.FloatField(max_digits=6, decimal_places=3)
   time = models.DateTimeField()


class RelayLog(models.Model):
   """ A log from an IRelay device of relat events/ """
   class Meta:
      db_table = "relaylog"

   class Admin:
      pass

   name = models.CharField(maxlength=128)
   status = models.CharField(maxlength=32)
   time = models.DateTimeField()

class UserLabel(models.Model):
   """ Attributes that may be applied to users.

   TODO(mikey): possibly deprecated.
   """
   class Meta:
      db_table = "userlabels"

   class Admin:
      pass

   user = models.ForeignKey(User)
   labelname = models.CharField(maxlength=128)

class Config(models.Model):
   class Meta:
      db_table = "config"

   class Admin:
      pass

   key = models.CharField(maxlength=128)
   value = models.TextField()

